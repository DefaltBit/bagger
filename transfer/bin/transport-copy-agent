#!/usr/bin/env perl

BEGIN {
	use File::Basename;
	use Cwd qw(abs_path);
	use lib abs_path(dirname($0) . "/../lib");
}

use strict;
use warnings;
use Fcntl qw(:flock);  ## import LOCK_* style constants
use Transfer::Process;
use Transport::Events;
use Transport::Tickets;

## Before we begin, make sure no other copy agent processes are running.
open(my $fh, ">/tmp/transport-copy-agent.lock");
unless (flock($fh, LOCK_EX | LOCK_NB)) {
    close($fh);
    my $name = basename $0;
    print "$name: Process already in use.  Exiting.\n";
    exit(0);
}


##----------------------------------------------------------------------

my $system = shift(@ARGV);
my $hostname = shift(@ARGV);
chomp($system = `hostname`) unless $system;
chomp($hostname = $system)  unless $hostname;

##----------------------------------------------------------------------

sub make_copy($$$$$$) {
    my ($event, $ticket, $src_host, $src, $dst_host, $dst) = @_;
    
    my $cmd = "$src_host tar czf - -C $src . | $dst_host tar zxvf - -C $dst";  
    do_task($hostname, $system, $event, $ticket, $cmd);
}

sub check_copy($$) {
    my ($ticket, $dir) = @_;
    my $event = "fixity verification";
    my $cmd = "transport-verify-package $dir";
    
    do_task_with_warnings($hostname, $system, $event, $ticket, $cmd);
}

##----------------------------------------------------------------------

sub one_step_copy($) {
    my $ticket = shift;
    
    my $source_ssh = "ssh $ticket->{source_user}\@$ticket->{source_host}";
    my $dest_ssh   = "ssh $ticket->{dest_user}\@$ticket->{dest_host}";
    

    run_or_fail($ticket->{id}, "$dest_ssh mkdir -p $ticket->{dest_dir}");
    
    make_copy("archive copy", $ticket->{id},
              $source_ssh, $ticket->{source_dir}, 
              $dest_ssh,   $ticket->{dest_dir});
                            
    ## Assume SSH to the destination was on the local system,
    ## and only used to preserve ownership.  Assume further that
    ## the current process can access this directory, and the
    ## file owner does not have access to the transport tools
    check_copy($ticket->{id}, $ticket->{dest_dir});
}

sub two_step_copy($) {
    my $ticket = shift;
    
    ## Assume transfer can log in as itself onto the source host
    my $ssh = "ssh $ticket->{source_host}";
    
    run_or_fail($ticket->{id}, "mkdir -p $ticket->{work_dir}");
    
    make_copy("workspace copy", $ticket->{id},
              $ssh, $ticket->{source_dir},
              "",   $ticket->{work_dir});
    check_copy($ticket->{id}, $ticket->{work_dir});

    ## Log in as the destination's owner on the current machine
    $ssh = "ssh $ticket->{dest_user}\@$ticket->{dest_host}";
    run_or_fail($ticket->{id}, "$ssh mkdir -p $ticket->{dest_dir}");
    
    make_copy("archive copy", $ticket->{id}, 
              "",   $ticket->{work_dir},
              $ssh, $ticket->{dest_dir});

    ## See above about checking the destination copy
    check_copy($ticket->{id}, $ticket->{dest_dir});

    ## The copy succeeded.  Purge the workspace _immediately_
    run_or_fail($ticket->{id}, "rm -Rf $ticket->{work_dir}");
}

##----------------------------------------------------------------------

sub register($) {
    my $ticket = shift;
    
    my $event = "location registration";
    my $inventory = "inventory --package $ticket->{package}";
    my $load      = "load-inventory --repository $ticket->{repo}";
    
    my $cmd = "cd $ticket->{dest_dir}; $inventory | $load";
    do_task($hostname, $system, "location registration", $ticket->{id}, $cmd);
}

##----------------------------------------------------------------------

## Get the first ticket in the queue
my ($ticket) = get_ticket_queue();

## Stop now if there's nothing to do
unless ($ticket) {
    my $name = basename $0;
    print "$name: No queued tickets.  Exiting.\n";
    exit(0);
}

## We have a ticket.  Mark this ticket as 'failed' if any errors occur 
## from here on.
track_ticket_failures(1);

$ticket->{workspace} ||= "";
start_ticket($ticket->{id});

if ($ticket->{workspace}) {
    two_step_copy($ticket);
} else {
    one_step_copy($ticket);
}

register($ticket);

finish_ticket($ticket->{id});

