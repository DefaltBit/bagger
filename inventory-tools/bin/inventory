#!/usr/bin/env perl

=head1 NAME

inventory - portable inventory tool

=head1 SYNOPSIS

inventory [OPTIONS] package_directory

  Options:
    --help              brief help message
    --ignore-invisible  ignore directories and files beginning with '.'
    --package-id        ID of the package being inventoried

=head1 DESCRIPTION

inventory walks an LC package and outputs a serialization of its contents
for loading into a package modeler.

=cut

use strict;
use warnings;
use File::Find;
use File::stat;
use File::Spec::Functions qw(rel2abs abs2rel splitpath);
use Digest::MD5;
use IO::File;
use Pod::Usage;
use Getopt::Long;
use Cwd;

our %OPTIONS;

sub observe($)
{
  my $abs_path = shift;
  my $stat = stat($abs_path);
  return {
    file    => $abs_path,
    mtime   => $stat->mtime,
    size    => $stat->size,
    md5     => md5($abs_path),
  }
}

sub observation_xml($) {
  my $observation = shift;
  my $relpath = abs2rel($observation->{file});
  my $mtime = scalar(localtime($observation->{mtime}));
<<EOF;
   <file>
    <path>$relpath</path>
    <fixity algorithm="md5">$observation->{md5}</fixity>
    <size>$observation->{size}</size>
    <created>$mtime</created>
   </file>
EOF
}

sub wanted($)
{
  my $abs_path = rel2abs shift;
  if ($OPTIONS{'ignore-invisible'} and is_invisible($abs_path))
  {
    $File::Find::prune = 1;
    return 0;
  }
  return -f $abs_path;
}

sub is_invisible($)
{
  my ($vol, $dirs, $file) = splitpath shift;
  return substr($file, 0, 1) eq '.'; 
}

sub md5($)
{
  my $abs_path = shift;
  my $md5 = Digest::MD5->new();
  my $handle = IO::File->new($abs_path);
  my $bytes;
  $md5->add($bytes) while $handle->read($bytes, 1024);
  return $md5->hexdigest();
}

sub print_observation($)
{
  return unless wanted $_;
  print observation_xml(observe($_));
}

sub xml_head($)
{
  my $basepath = shift;
  my $created = scalar(localtime());
  chomp(my $service = `hostname`);
  my $package_id = $OPTIONS{'package-id'} ? $OPTIONS{'package-id'} : '';

<<EOF;
<inventory>
 <location>
  <package-id>$package_id</package-id>
  <storage-service>$service</storage-service>
  <base-path>$basepath</base-path>
  <created>$created</created>
  <file-instances>
EOF
}

sub xml_foot
{
<<EOF;    
  </file-instances>
 </location>
</inventory>
EOF
}

sub print_inventory($) {
  my $basepath = rel2abs shift;
  print xml_head $basepath;

  # chdir to allow observation_xml() to correctly determine relative paths
  my $old_dir = chdir $basepath;
  find {wanted => \&print_observation, no_chdir => 1}, $basepath;
  chdir $old_dir;

  print xml_foot;
}

if ($0 =~ /inventory$/)
{
  # gather OPTIONS
  GetOptions \%OPTIONS, 'help', 'ignore-invisible', 'package-id=s';

  # print help if appropriate
  pod2usage({exitval => 0, verbose => 2}) if $OPTIONS{help};

  # get the package directory
  my $package_dir = shift;
  unless ($package_dir and -d $package_dir)
  {
    pod2usage {exitval => 1, verbose => 1};
  }

  print_inventory $package_dir;
}

1;
