<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
	<sql-query name="findFileInstancesMinusFileExaminations">
		<![CDATA[
select fi.relative_path as "relativePath", fi.base_name as "baseName", fi.extension as "extension" 
from core.fileinstance fi
inner join core.filelocation fl on fi.filelocation_key=fl.pkey
left outer join
(
	select fe.relative_path, fe.base_name, fe.extension, fe.pkey
	from core.fileexamination fe
	inner join core.fileexamination_group feg on feg.pkey=fe.fileexamination_group_key
	where feg.pkey=:fileexaminationgroupkey
) t on fi.relative_path=t.relative_path and fi.base_name=t.base_name and fi.extension=t.extension
where fl.pkey=:filelocationkey
and t.pkey is null
		]]>
	</sql-query>	
	<sql-query name="findFileExaminationsMinusFileInstances">
		<![CDATA[
select fe.relative_path as "relativePath", fe.base_name as "baseName", fe.extension as "extension" 
from core.fileexamination fe
inner join core.fileexamination_group feg on feg.pkey=fe.fileexamination_group_key
left outer join
(
	select fi.relative_path, fi.base_name, fi.extension, fi.pkey
	from core.fileinstance fi
	inner join core.filelocation fl on fi.filelocation_key=fl.pkey
	where fl.pkey=:filelocationkey	
) t on fe.relative_path=t.relative_path and fe.base_name=t.base_name and fe.extension=t.extension
where feg.pkey=:fileexaminationgroupkey
and t.pkey is null
		]]>
	</sql-query>	
	<sql-query name="findFileExaminationsFileInstancesIncomparable">
		<![CDATA[
select distinct fi2.relative_path as "relativePath", fi2.base_name as "baseName", fi2.extension as "extension" 
from core.fileinstance fi2
inner join core.filelocation fl2 on fi2.filelocation_key=fl2.pkey
inner join core.fileinstance_fixity fif2 on fi2.pkey=fif2.fileinstance_key
left outer join 
(
	select distinct fi.relative_path, fi.base_name, fi.extension
	from core.fileinstance fi
	inner join core.filelocation fl on fi.filelocation_key=fl.pkey
	inner join core.fileinstance_fixity fif on fi.pkey=fif.fileinstance_key
	inner join core.fileexamination fe on fi.relative_path=fe.relative_path and fi.base_name=fe.base_name and fi.extension=fe.extension
	inner join core.fileexamination_group feg on feg.pkey=fe.fileexamination_group_key
	inner join core.fileexamination_fixity fef on fe.pkey=fef.fileexamination_key and fif.algorithm=fef.algorithm
	where feg.pkey=:fileexaminationgroupkey
	and fl.pkey=:filelocationkey
) t  on fi2.relative_path=t.relative_path and fi2.base_name=t.base_name and fi2.extension=t.extension
inner join
(
	select distinct fe2.relative_path, fe2.base_name, fe2.extension
	from core.fileexamination fe2
	inner join core.fileexamination_group feg2 on feg2.pkey=fe2.fileexamination_group_key
	inner join core.fileexamination_fixity fef2 on fe2.pkey=fef2.fileexamination_key
	where feg2.pkey=:fileexaminationgroupkey
) t2  on fi2.relative_path=t2.relative_path and fi2.base_name=t2.base_name and fi2.extension=t2.extension
where fl2.pkey=:filelocationkey
and t.base_name is null
		]]>
	</sql-query>	
	<sql-query name="findFileExaminationsFileInstancesMismatch">
		<![CDATA[
select distinct fi.relative_path as "relativePath", fi.base_name as "baseName", fi.extension as "extension" 
from core.fileinstance fi
inner join core.filelocation fl on fi.filelocation_key=fl.pkey
inner join core.fileinstance_fixity fif on fi.pkey=fif.fileinstance_key
inner join core.fileexamination fe on fi.relative_path=fe.relative_path and fi.base_name=fe.base_name and fi.extension=fe.extension
inner join core.fileexamination_group feg on feg.pkey=fe.fileexamination_group_key
inner join core.fileexamination_fixity fef on fe.pkey=fef.fileexamination_key and fif.algorithm=fef.algorithm
where feg.pkey=:fileexaminationgroupkey
and fl.pkey=:filelocationkey
and fif.fixity_value != fef.fixity_value
union
select fe2.relative_path as "relativePath", fe2.base_name as "baseName", fe2.extension as "extension" 
from core.fileexamination fe2
inner join core.fileexamination_group feg2 on feg2.pkey=fe2.fileexamination_group_key
left outer join core.fileexamination_fixity fef2 on fe2.pkey=fef2.fileexamination_key
where feg2.pkey=:fileexaminationgroupkey
and fef2.algorithm is null
		]]>
	</sql-query>	
<!-- Start -->
	<sql-query name="findCanonicalFilesMinusFileInstances">
		<![CDATA[
select cf.relative_path as "relativePath", cf.base_name as "baseName", cf.extension as "extension" 
from core.canonicalfile cf
left outer join
(
	select fi.relative_path, fi.base_name, fi.extension, fi.pkey
	from core.fileinstance fi
	inner join core.filelocation fl on fi.filelocation_key=fl.pkey
	where fl.pkey=:filelocationkey
) t on cf.relative_path=cf.relative_path and cf.base_name=t.base_name and cf.extension=t.extension
where cf.package_key=:packagekey
and t.pkey is null
		]]>
	</sql-query>	
	<sql-query name="findFileInstancesMinusCanonicalFiles">
		<![CDATA[
select fi.relative_path as "relativePath", fi.base_name as "baseName", fi.extension as "extension" 
from core.fileinstance fi
inner join core.filelocation fl on fi.filelocation_key=fl.pkey
left outer join
(
	select cf.relative_path, cf.base_name, cf.extension, cf.pkey
	from core.canonicalfile cf
	where cf.package_key=:packagekey
) t on fi.relative_path=t.relative_path and fi.base_name=t.base_name and fi.extension=t.extension
where fl.pkey=:filelocationkey
and t.pkey is null
		]]>
	</sql-query>	
	<sql-query name="findCanonicalFilesFileInstancesIncomparable">
		<![CDATA[
select distinct cf2.relative_path as "relativePath", cf2.base_name as "baseName", cf2.extension as "extension" 
from core.canonicalfile cf2
left outer join 
(
	select distinct cf.relative_path, cf.base_name, cf.extension
	from core.canonicalfile cf
	inner join core.canonicalfile_fixity cff on cf.pkey=cff.canonicalfile_key
	inner join core.fileinstance fi on cf.relative_path=fi.relative_path and cf.base_name=fi.base_name and cf.extension=fi.extension
	inner join core.filelocation fl on fl.pkey=fi.filelocation_key
	inner join core.fileinstance_fixity fif on fi.pkey=fif.fileinstance_key and cff.algorithm=fif.algorithm
	where cf.package_key=:packagekey
	and fl.pkey=:filelocationkey
) t  on cf2.relative_path=t.relative_path and cf2.base_name=t.base_name and cf2.extension=t.extension
where cf2.package_key=:packagekey
and t.base_name is null
		]]>
	</sql-query>	
	<sql-query name="findCanonicalFilesFileInstancesMismatch">
		<![CDATA[
select distinct cf.relative_path as "relativePath", cf.base_name as "baseName", cf.extension as "extension" 
from core.canonicalfile cf
inner join core.canonicalfile_fixity cff on cf.pkey=cff.canonicalfile_key
inner join core.fileinstance fi on cf.relative_path=fi.relative_path and cf.base_name=fi.base_name and cf.extension=fi.extension
inner join core.filelocation fl on fl.pkey=fi.filelocation_key
inner join core.fileinstance_fixity fif on fi.pkey=fif.fileinstance_key and cff.algorithm=fif.algorithm
where cf.package_key=:packagekey
and fl.pkey=:filelocationkey
and cff.fixity_value != fif.fixity_value
		]]>
	</sql-query>	

	<!-- 
	<sql-query name="findCanonicalFileListMinusFileInstanceList">
		<![CDATA[
		select cf.relative_path as "relativePath", cf.base_name as "baseName", cf.extension as "extension"
		from canonicalfile cf
		inner join package p1 on cf.package_key=p1.pkey
		inner join repository r1 on p1.repository_key=r1.pkey
		left outer join 
		(
			select fi.relative_path, fi.base_name, fi.extension, fl.package_key
			from fileinstance fi
			inner join filelocation fl on fi.filelocation_key=fl.pkey
			inner join agentmodeler_agent a on fl.storageservice_key=a.pkey
			and a.agent_id = :storageserviceid
			and fl.base_path = :basepath
		) t on cf.relative_path=t.relative_path and cf.base_name=t.base_name and cf.extension=t.extension and cf.package_key=t.package_key
		where p1.package_id = :packageid
		and r1.repository_id= :repositoryid
		and t.package_key is null
		]]>
	</sql-query>	
	<sql-query name="findFileInstanceListMinusCanonicalFileList">
		<![CDATA[
		select fi.relative_path as "relativePath", fi.base_name as "baseName", fi.extension as "extension"
		from fileinstance fi
		inner join filelocation fl on fi.filelocation_key=fl.pkey
		inner join agentmodeler_agent a on fl.storageservice_key=a.pkey
		inner join package p1 on fl.package_key=p1.pkey
		inner join repository r1 on p1.repository_key=r1.pkey
		left outer join
		(
			select cf.relative_path, cf.base_name, cf.extension, cf.package_key
			from canonicalfile cf
		) t on fi.relative_path=t.relative_path and fi.base_name=t.base_name and fi.extension=t.extension and fl.package_key=t.package_key
		where p1.package_id = :packageid
		and r1.repository_id= :repositoryid
		and a.agent_id = :storageserviceid
		and fl.base_path = :basepath
		and t.package_key is null
		]]>
	</sql-query>		
	<sql-query name="findCanonicalFileListFileInstanceListFixityMismatchList">
		<![CDATA[
		select distinct cf.relative_path as "relativePath", cf.base_name as "baseName", cf.extension as "extension"
		from canonicalfile cf
		inner join fileinstance fi on cf.relative_path=fi.relative_path and cf.base_name=fi.base_name and cf.extension=fi.extension
		inner join canonicalfile_fixity cff on cf.pkey=cff.canonicalfile_key
		inner join fileinstance_fixity fif on fi.pkey=fif.fileinstance_key
		inner join filelocation fl on fi.filelocation_key=fl.pkey
		inner join agentmodeler_agent a on fl.storageservice_key=a.pkey
		inner join package p1 on cf.package_key=p1.pkey
		inner join repository r1 on p1.repository_key=r1.pkey
		where p1.package_id = :packageid
		and r1.repository_id= :repositoryid
		and fl.package_key = cf.package_key
		and a.agent_id = :storageserviceid
		and fl.base_path = :basepath
		and cff.algorithm_key=fif.algorithm_key
		and cff.fixity_value != fif.fixity_value	
		]]>
	</sql-query>	
	<sql-query name="findCanonicalFileListFileInstanceListIncomparableList">
		<![CDATA[
		select cf1.relative_path as "relativePath", cf1.base_name as "baseName", cf1.extension as "extension"
		from canonicalfile cf1
		inner join fileinstance fi1 on cf1.relative_path=fi1.relative_path and cf1.base_name=fi1.base_name and cf1.extension=fi1.extension
		inner join filelocation fl1 on fi1.filelocation_key=fl1.pkey
		inner join agentmodeler_agent a on fl1.storageservice_key=a.pkey
		inner join package p on cf1.package_key=p.pkey
		inner join repository r on p.repository_key=r.pkey
		left outer join
		(
			select cf2.relative_path, cf2.base_name, cf2.extension, fl2.pkey
			from canonicalfile cf2
			inner join fileinstance fi2 on cf2.relative_path=fi2.relative_path and cf2.base_name=fi2.base_name and cf2.extension=fi2.extension
			inner join canonicalfile_fixity cff on cf2.pkey=cff.canonicalfile_key
			inner join fileinstance_fixity fif on fi2.pkey=fif.fileinstance_key
			inner join filelocation fl2 on fi2.filelocation_key=fl2.pkey
			where fl2.package_key = cf2.package_key
			and cff.algorithm_key=fif.algorithm_key
			group by cf2.relative_path, cf2.base_name, cf2.extension, fl2.pkey
		) t on fi1.relative_path=t.relative_path and fi1.base_name=t.base_name and fi1.extension=t.extension and fl1.pkey=t.pkey
		where fl1.package_key = cf1.package_key
		and p.package_id = :packageid
		and r.repository_id= :repositoryid
		and a.agent_id = :storageserviceid
		and fl1.base_path = :basepath
		and t.pkey is null
		]]>
	</sql-query>	
		
	<sql-query name="findNotPresentFileObservationList">
		<![CDATA[
		select fi.relative_path as "relativePath", fi.base_name as "baseName", fi.extension as "extension"
		from fileobservation_most_recent fo
		inner join fileinstance fi on fo.base_name=fi.base_name and fo.extension=fi.extension and fo.relative_path=fi.relative_path and fo.filelocation_key=fi.filelocation_key
		inner join filelocation fl on fo.filelocation_key=fl.pkey
		inner join package p on fl.package_key=p.pkey
		inner join repository r on p.repository_key=r.pkey
		inner join agentmodeler_agent a on fl.storageservice_key=a.pkey
		where fo.present_flag=false
		and p.package_id = :packageid
		and r.repository_id= :repositoryid
		and a.agent_id = :storageserviceid
		and fl.base_path = :basepath
		]]>
	</sql-query>	
	<sql-query name="findAddditionalFileObservationList">
		<![CDATA[
		select fo.relative_path as "relativePath", fo.base_name as "baseName", fo.extension as "extension"
		from fileobservation_most_recent fo
		inner join filelocation fl on fo.filelocation_key=fl.pkey
		inner join package p on fl.package_key=p.pkey
		inner join repository r on p.repository_key=r.pkey
		inner join agentmodeler_agent a on fl.storageservice_key=a.pkey
		left outer join fileinstance fi on fo.base_name=fi.base_name and fo.extension=fi.extension and fo.relative_path=fi.relative_path and fo.filelocation_key=fi.filelocation_key
		where ((fo.present_flag=false and fi.filelocation_key is not null) or (fi.filelocation_key is null and fo.present_flag=true))
		and p.package_id = :packageid
		and r.repository_id= :repositoryid
		and a.agent_id = :storageserviceid
		and fl.base_path = :basepath
		]]>
	</sql-query>	
	<sql-query name="findFileInstanceListFileObservationListFixityMismatchList">
		<![CDATA[
		select distinct fo.relative_path as "relativePath", fo.base_name as "baseName", fo.extension as "extension"
		from fileobservation_most_recent fo
		inner join filelocation fl on fo.filelocation_key=fl.pkey
		inner join package p on fl.package_key=p.pkey
		inner join repository r on p.repository_key=r.pkey
		inner join agentmodeler_agent a on fl.storageservice_key=a.pkey
		inner join fileobservation_fixity fof on fo.pkey=fof.fileobservation_key
		inner join
		(
			select fi.relative_path, fi.base_name, fi.extension, fi.filelocation_key, fif.algorithm_key, fif.fixity_value
			from fileinstance fi
			inner join fileinstance_fixity fif on fi.pkey=fif.fileinstance_key
		) t on fo.base_name=t.base_name and fo.extension=t.extension and fo.relative_path=t.relative_path and fo.filelocation_key=t.filelocation_key and fof.algorithm_key=t.algorithm_key		
		where fo.present_flag=true
		and fof.fixity_value != t.fixity_value
		and p.package_id = :packageid
		and r.repository_id= :repositoryid
		and a.agent_id = :storageserviceid
		and fl.base_path = :basepath
		]]>
	</sql-query>			
	<sql-query name="findFileInstanceListFileObservationListIncomparableList">
		<![CDATA[
		select distinct fi1.relative_path as "relativePath", fi1.base_name as "baseName", fi1.extension as "extension"
		from fileinstance fi1
		inner join filelocation fl on fi1.filelocation_key=fl.pkey
		inner join package p on fl.package_key=p.pkey
		inner join repository r on p.repository_key=r.pkey
		inner join agentmodeler_agent a on fl.storageservice_key=a.pkey		
		left outer join fileobservation_most_recent fo on fi1.relative_path=fo.relative_path and fi1.base_name=fo.base_name and fi1.extension=fo.extension and fi1.filelocation_key=fo.filelocation_key
		left outer join
		(
			select fi2.relative_path, fi2.base_name, fi2.extension, fi2.filelocation_key
			from fileinstance fi2
			inner join fileinstance_fixity fif on fi2.pkey=fif.fileinstance_key
			inner join fileobservation_checkable foc on fi2.relative_path=foc.relative_path and fi2.base_name=foc.base_name and fi2.extension=foc.extension and fi2.filelocation_key=foc.filelocation_key
			inner join fileobservation_fixity fof on foc.pkey=fof.fileobservation_key
			where fif.algorithm_key=fof.algorithm_key
		) t on fi1.relative_path=t.relative_path and fi1.base_name=t.base_name and fi1.extension=t.extension and fi1.filelocation_key=t.filelocation_key
		where t.filelocation_key is null
		and (fo.present_flag=true or fo.present_flag is null)
		and p.package_id = :packageid
		and r.repository_id= :repositoryid
		and a.agent_id = :storageserviceid
		and fl.base_path = :basepath				
		]]>
	</sql-query>			
	-->
</hibernate-mapping>